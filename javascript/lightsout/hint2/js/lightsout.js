window.onload = function() {

  /** ライツアウトのチェックボックス要素リスト */
  var lightsList = Array.prototype.slice.call(document.getElementsByClassName("light"));
  /** Start/Stop ボタンオブジェクト */
  var toggleButton = document.getElementById("toggle");
  /** Shuffle ボタンオブジェクト */
  var shuffleButton = document.getElementById("shuffle");
  /** ボードのサイズ */
  var sizeOfBoard = 5;
  /** ゲーム中をあらわすフラグ */
  var inGame = false;

  toggleButton.innerHTML = "Start";    /* Start ボタンの文字を設定する */

  /**
   * それぞれのチェックボックスにイベントを登録する。
   */
  for(var i = 0, num = lightsList.length; i < num; ++i) {
    lightsList[i].onclick = function() {
      executeElement(this);
    }
  }

  /**
   * チェックボックスのインデックスを取得する
   */
  function getIndex(element) {
    return lightsList.indexOf(element);
  }

  /**
   * Start/Stop ボタンを押下した時の処理
   * inGame フラグのtrue/false を切り替える
   */
  toggleButton.onclick = function() {
    // FIXME: 現状では一方的にON にすることしかできないので、
    //        Start/Stop ボタンをクリックすることで、inGame フラグがtrue/false に切り替わるようにする。
    ////      inGame が既にON になっているときには、OFF になるように、
    ////      inGame が既にOFF になっているときには、ON になるようにし、
    ////      その時のボタンの文字列の表示もわかりやすいものに切り替わるようにする。
    //////
    //////    ボタンの文字列を変更するには、
    //////      toggleButton.innerHTML = "Some string"
    //////    のようにする。
    //////    inGame フラグを切り替える流れとしては…
    //////
    //////      もし、inGame フラグがtrue (ゲーム中)の場合
    //////        -> inGame フラグをfalse にする
    //////           ボタンを"Start" という文字に変える
    //////      もし、inGame フラグがfalse (ゲーム停止中)の場合
    //////        -> inGame フラグをtrue にする
    //////           ボタンを"Stop" という文字に変える
    //////
    //////      ・Sample Code
    //////      if(inGame === true) {
    //////        // inGame をfalse
    //////        // ボタンを"Start" という文字に変える
    //////      } else {
    //////        // inGame をtrue
    //////        // ボタンを"Stop" という文字に変える
    //////      }
    //////
    inGame = true;
  }

  /**
   * Shuffle ボタンを押下した時のイベント
   */
  shuffleButton.onclick = function() {
    // FIXME: 各ボタンのチェック状態をシャッフルする
    ////      ランダムな値を返す関数を使用すると便利。
    //////
    //////    ランダムな値を返す関数はMath.random を使うことで
    //////    0 以上1 未満(0 〜 0.999....) の範囲で乱数を取得することができる。
    //////
    //////    チェックボックスがON もしくはOFF となっている状態を0, もしくは1 であると考えると、
    //////    0 以上2 未満の乱数(0 もしくは1)を取得できると都合がいい。
    //////    Math.random() をそのまま使うと、0 もしくは1 を綺麗に取得することができないので、
    //////    工夫する必要がある。
    //////    やり方は何通りかあると思うが、一例として、Math.random() の結果を2 倍して
    //////    その結果の小数点以下を切り捨てることで、綺麗に0 もしくは1 の値が取得することができる。
    //////    小数点以下を切り捨てるには、Math.floor(number) 関数を使うことで取得することができる。
    //////      var result = Math.floor(Math.random() * 2 / 2)    // <- result に0 か1 かの結果が入っている
  }

  /**
   * ゲームが終了しているか判定する。
   * ゲームが終了している場合は、return true を、
   * ゲームが終了していない場合は、return false を返す。
   */
  function isGameOver() {
    // FIXME: ゲームの終了判定を行う
    ////      ゲーム終了条件は、すべてのチェックボックスのチェックがOFF になっている時。
    //////
    //////    すべてのチェックボックスの要素はlightsList 配列に格納されているので、
    //////    lightsList 配列に入っているそれぞれのチェックボックスに
    //////    チェックがされてい無いことを確認すればよい。
    //////
    //////    すべてのチェックボックス要素を舐めるにはfor 構文を用いて
    //////    チェックボックスの数分だけ繰り返し処理を行うことで可能。
    //////    チェックボックスが全部でいくつかるかを取得するには
    //////      lightsList.length
    //////    と書くことで取得できる。
    //////
    //////    for 構文の書き方は...
    //////
    //////      for(初期値; 繰り返し条件; 継続処理) {
    //////        // 処理
    //////      }
    //////
    //////    というふうに書くことでできる。
    //////
    //////    for(var i = 0; i < lightsList.length; i++) {
    //////      // 一つでもチェックされているボタンがあれば
    //////      // ゲームが終了していないということなので、
    //////      // チェックされているチェックボックスが見つかり次第
    //////      // false を返すようにすれば良い。
    //////      if(lightList[i].checked) {
    //////        return false;
    //////      }
    //////    }
    //////
    // return true or false
  }

  function executeElement(element) {

    var index = getIndex(element);

    // FIXME: ゲームがまだ開始していない場合は周りのボタンを反転しない
    ////      ゲームの状態がゲーム中ではない場合は、処理をreturn する。

    // FIXME: クリックしたところの上のマスの状態を反転する
    //        左上から順番に... 0〜24 のindex が割り当てられるので、
    //        クリックしたところの上のマス目のindex を四則演算で求めることができる。
    //
    ////      クリックしたところの上のボタンの状態を確認し
    ////      そこが既にチェックされている状態であればチェックを解除し、
    ////      まだチェックされていない状態であればチェックを入れる。
    ////
    ////      5 * 5 のマスになっているので、
    ////      一番左上のチェックボックスはindex[0] となり、
    ////      一番上のチェックボックスはindex[4] となり、
    ////      一番下のチェックボックスはindex[24] となる。
    ////      チェックしたボタンの上のボタンを求めるには、
    ////      例えばチェックしたボタンがindex[12] だとすると…
    //////
    //////    index[7] となる
    //////    (これがピンと来ない場合は、実際に図を描いて確認をしてみると良い)。
    //////    index[12] をクリックした時にindex[7] のチェックボックスを導き出すには、
    //////    このLightsOut は5 * 5 のマスなので、index[12] の上部のチェックボックスを求めるには
    //////    12 から5 減算することで可能。
    //////      index[12 - 7]
    //////
    //////    これを、5 * 5 = 25 マス分すべて記述すれば
    //////    クリックしたチェックボックスの上のチェックボックスを求めることができる…
    //////    が、これではあまりにコストがかかるので、もっと抽象的に記述するようにする。
    //////
    //////    LightsOut のボードのサイズ(5)はsizeOfBoard 変数に格納されいる。
    //////    現在クリックしたチェックボックスの位置(12) はindex 変数に格納されている。
    //////    これらを利用することで、(index - sizeOfBoard) という計算式で、
    //////    一つ上のチェックボックスの位置を求めることができる。
    //////
    //////    更に、一つ上のチェックボックスのチェックを反転させるには、
    //////    一つ上のチェックボックスの状態をif 構文を使って確認して、
    //////    既にチェックされている場合はチェックを解除し、
    //////    まだチェックされていない場合はチェックを入れるようにする。
    //////
    //////    if(lightsList[index - sizeOfBoard].checked === true) {
    //////      // 1 つ上のチェックボックスが既にチェックされている場合は、
    //////      // そこのチェックを解除する
    //////      lightsList[index - sizeOfBoard].checked = false;
    //////    } else {
    //////      // 1 つ上のチェックボックスがまだチェックされていない場合は、
    //////      // そこにチェックを入れる
    //////      lightsList[index - sizeOfBoard].checked = true;
    //////    }


    // FIXME: クリックしたところの右のマスの状態を反転する
    ////
    ////      クリックしたところの右のボタンの状態を確認し
    ////      そこが既にチェックされている状態であればチェックを解除し、
    ////      まだチェックされていない状態であればチェックを入れる。
    ////
    ////      5 * 5 のマスになっているので、
    ////      一番左上のチェックボックスはindex[0] となっているので
    ////      例えばチェックしたボタンがindex[12] だとすると…
    //////
    //////    一つ上のチェックボックスのチェックを反転する処理の例と同様に、
    //////    index[12] のチェックボックスがクリックされた場合、
    //////    右のマスはindex[13] となる。
    //////    同様に計算式で求めようとすると。
    //////      index[12 + 1]
    //////    となる。
    //////
    //////    これを変数を使って処理を記述すると
    //////
    //////      if(lightsList[index + 1].checked === true) {
    //////        lightsList[index + 1].checked = false;
    //////      } else {
    //////        lightsList[index + 1].checked = true;
    //////      }
    //////
    //////    となる。
    //////    なお、ボードの右端をクリックしても問題なく想定通りの挙動をするかどうかを確認すること。


    // FIXME: クリックしたところの下のマスの状態を反転する
    ////
    ////      クリックしたところの下のボタンの状態を確認し
    ////      そこが既にチェックされている状態であればチェックを解除し、
    ////      まだチェックされていない状態であればチェックを入れる。
    ////
    ////      5 * 5 のマスになっているので(以下略)
    //////
    //////    クリックしたところのチェックボックスをindex[12] とすると
    //////      index[12 + 5]
    //////    となる。

    // FIXME: クリックしたところの左のマスの状態を反転する
    ////
    ////      クリックしたところの左のボタンの状態を確認し
    ////      そこが既にチェックされている状態であればチェックを解除し、
    ////      まだチェックされていない状態であればチェックを入れる。
    ////
    ////      5 * 5 のマスになっているので(以下略)
    //////
    //////    クリックしたところのチェックボックスをindex[12] とすると
    //////      index[12 - 1]
    //////    となる。

    // FIXME: ゲームの終了判定を行う
    //        isGameOver() 関数に実装する
    ////      isGameOver() 関数にゲームが終了しているかどうかの判定を実装し、
    ////      ゲームが終了している場合(true) はゲームを終了し、
    ////      ゲームが終了していない場合(false) はゲームを続行する。
    ////      ゲーム終了時は、終了のメッセージを何かしらの方法で表示するようにする。
    //////
    //////    if(isGameOver() === true) {
    //////      alert("Clear!");
    //////    }
  }
};

